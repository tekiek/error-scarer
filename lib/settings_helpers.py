import json
import os
import sys
import socket

import tornado.options


tornado.options.define('environment', default='dev', help='environment')


NOT_FOUND = object()


def make_settings(app_name, default_settings, environment_settings, host_settings=None):
    host_settings = host_settings or {}

    assert isinstance(default_settings, dict)
    assert isinstance(environment_settings, dict)
    assert isinstance(host_settings, dict)

    assert all(isinstance(k, basestring) and isinstance(v, dict)
               for k, v in environment_settings.iteritems())
    assert all(isinstance(k, basestring) and isinstance(v, dict)
               for k, v in host_settings.iteritems())

    # Handle the different names for environments that chef and ansible use.
    # TODO: https://buzzfeed.atlassian.net/browse/DATAINFRA-542
    environment_settings.setdefault('development', environment_settings.get('dev', {}))
    environment_settings.setdefault('production', environment_settings.get('live', {}))

    def env():
        return tornado.options.options.environment

    def get(key):
        current_env = env()
        if current_env not in environment_settings:
            raise Exception('Invalid Environment (%s)' % current_env)

        v = os.environ.get(key.upper(), NOT_FOUND)

        if v is NOT_FOUND:
            v = local_settings(app_name).get(key, NOT_FOUND)

        if v is NOT_FOUND:
            v = host_settings.get(hostname(), {}).get(key, NOT_FOUND)

        if v is NOT_FOUND:
            v = environment_settings.get(current_env).get(key, NOT_FOUND)

        if v is NOT_FOUND:
            v = default_settings.get(key, NOT_FOUND)

        if v is NOT_FOUND:
            raise RuntimeError('key %s not in any settings' % key)

        if callable(v):
            return v()

        return v

    return get, env


def memoized(f, cache={}):
    def decorated(*args):
        key = (f.__name__, args)
        try:
            return cache[key]
        except KeyError:
            cache[key] = f(*args)
            return cache[key]
    return decorated


@memoized
def hostname():
    fqdn = socket.gethostname()
    return 'dev.buzzfeed.org' if fqdn.endswith('.buzzfeed.org') else fqdn


@memoized
def local_settings(app_name):
    # TODO: we want to standardize on the first path for settings generated by
    # config management, but we have instances of the other paths out in the
    # wild.
    paths = [
        '/buzzfeed/local/conf/{app_name}_conf.json',
        '/buzzfeed/local/conf/{app_name}_settings.json',
        '/buzzfeed/local/conf/{app_name}/settings.json',
    ]
    try:
        for path in paths:
            try:
                with open(path.format(app_name=app_name)) as f:
                    settings = json.load(f)
                    assert isinstance(settings, dict)
                    return settings
            except IOError:
                continue
    except Exception, e:
        raise RuntimeError('Invalid local settings.json: %s' % e)
    return {}


def main(get):
    tornado.options.define('key')
    tornado.options.parse_command_line()

    value = get(tornado.options.options.key)
    if isinstance(value, basestring):
        sys.stdout.write(value)
    else:
        sys.stdout.write(json.dumps(value))
